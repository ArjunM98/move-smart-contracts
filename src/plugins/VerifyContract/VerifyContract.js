/*globals define*/
/*eslint-env node, browser*/

const { setFlagsFromString } = require('v8');

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Sat Nov 28 2020 18:00:45 GMT-0500 (Eastern Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'scsrc/ModelTransformation/conformanceTransformation',
    'scsrc/ModelTransformation/augmentTransitionSystem',
    'common/util/guid',
    'ejs'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    conformanceTransformation,
    AugmentTransitionSystem,
    guid,
    ejs) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of VerifyContract.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin VerifyContract.
     * @constructor
     */
    function VerifyContract() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
        this.AugmentTransitionSystem = new AugmentTransitionSystem;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    VerifyContract.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    VerifyContract.prototype = Object.create(PluginBase.prototype);
    VerifyContract.prototype.constructor = VerifyContract;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    VerifyContract.prototype.main = function (callback) {
        // Use this to access core, project, result, logger etc from PluginBase.
        var self = this,
            path,
            fs,
            filesToAdd = {},
            artifact;

        if (typeof window == 'undefined') {
            // Get current working directory
            path = process.cwd();
            // file system library
            fs = require('fs');
            // define projectOutputs directory
            if (!fs.existsSync('projectOutputs')) {
                fs.mkdirSync('projectOutputs');
            }
            // define path for where verfification files will be placed
            path += '/projectOutputs/' + self.core.getAttribute(self.activeNode, 'name') + guid();
            path = path.replace(/\s+/g, '');
        }

        // Loads all the nodes in the subtree starting from node and returns a map from paths to nodes.
        self.loadNodeMap(self.activeNode).then(function (nodes) {
            return VerifyContract.getVerificationResults(self, nodes, fs, path)
        }).then(function () {
            // writes verification output to the blob storage used (monogdb)
            filesToAdd['output.txt'] = fs.readFileSync(path + '/output.txt_translated.txt', 'utf8');
            artifact = self.blobClient.createArtifact('VerificationOutput');
            return artifact.addFiles(filesToAdd);
        }).then(function (fileHash) {
            self.result.addArtifact(fileHash);
            return artifact.save();
        }).then(function () {
            self.result.setSuccess(true);
            callback(null, self.result)
        }).catch(function (err) {
            self.logger.error(err.stack);
            callback(err, self.result);
        })
    };

    /**
     * Verification function which invokes verify on each set of contracts
     * @param self - Reference to self object
     * @param nodes - Current node structure of modelling elements in project tree
     * @param fs - file system
     * @param path - path to write output files to
     */
    VerifyContract.getVerificationResults = function (self, nodes, fs, path) {
        var contract;
        // for multiple contracts, verify each one
        for (contract of VerifyContract.prototype.getContractPaths.call(self, nodes))
            VerifyContract.prototype.verifyContract.call(self, nodes, contract, fs, path);
    };

    /**
     * Get's contract path based on the node structure
     * @param nodes - Current node structure of modelling elements in project tree
     */
    VerifyContract.prototype.getContractPaths = function (nodes) {
        var self = this,
            path,
            node,
            //Using an array for the multiple contracts extention
            contracts = [];

        for (path in nodes) {
            node = nodes[path];
            if (self.isMetaTypeOf(node, self.META.Contract)) {
                contracts.push(path);
            }
        }
        return contracts;
    };

    /**
     * 
     * @param nodes - Current node structure of modelling elements in project tree
     * @param contract - path to current contract node 
     * @param fs - file system
     * @param path - path to write output files to
     */
    VerifyContract.prototype.verifyContract = function (nodes, contract, fs, path) {

        var self = this;

        // If current verification tool nuXmv has not been downloaded, process cannot complete
        //if (!fs.existsSync('./verificationTools/nuXmv')) {
        //    throw new Error('The NuSMV tool was not added. Please follow the instructions of the README file to add the NuSMV tool.');
        //}

        // Build model structure
        var model = VerifyContract.prototype.buildModel.call(self, nodes, contract);

        // Safely integrate initial action into model interface
        model = conformanceTransformation(model);

        // Augment Model 
        model = self.AugmentTransitionSystem.augmentModel(model);

    }

    /**
     * 
     * Given node structure and specified contract, builds the main model structure
     * 
     * @param nodes - Current node structure of modelling elements in project tree
     * @param contract - path to current contract node 
     */
    VerifyContract.prototype.buildModel = function (nodes, contract) {

        var self = this;

        // extract contract specific nodes
        var node = nodes[contract];
        var name = self.core.getAttribute(node, 'name');

        // get path of each child node from contract main node
        var pathToName = {};
        for (const childPath of self.core.getChildrenPaths(node))
            pathToName[childPath] = self.core.getAttribute(nodes[childPath], 'name');

        var states = [],
            transitions = [],
            finalStates = [],
            initialState;

        // Building model object attributes 
        for (const childPath of self.core.getChildrenPaths(node)) {
            var child = nodes[childPath];
            var childName = self.core.getAttribute(child, 'name');

            if (self.isMetaTypeOf(child, self.META.State))
                states.push(childName);
            else if (self.isMetaTypeOf(child, self.META.InitialState)) {
                states.push(childName);
                initialState = childName;
            }
            else if (self.isMetaTypeOf(child, self.META.FinalState)) {
                states.push(childName);
                finalStates.push(childName);
            }
            else if (self.isMetaTypeOf(child, self.META.Transition)) {
                const transition = {
                    'name': childName,
                    'src': pathToName[self.core.getPointerPath(child, 'src')],
                    'dst': pathToName[self.core.getPointerPath(child, 'dst')],
                    'guards': self.core.getAttribute(child, 'guards'),
                    'input': self.core.getAttribute(child, 'input'),
                    'output': self.core.getAttribute(child, 'output'),
                    'statements': self.core.getAttribute(child, 'statements'),
                    'tags': self.core.getAttribute(child, 'tags')
                };
                transitions.push(transition);
            }
        }

        // Complete model object built from nodes
        return {
            'name': name,
            'states': states,
            'transitions': transitions,
            'initialState': initialState,
            'finalStates': finalStates,
            'initialAction': self.core.getAttribute(node, 'initialAction'),
        };
    }

    return VerifyContract;
});
