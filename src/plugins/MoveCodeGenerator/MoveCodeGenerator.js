/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Fri Jan 08 2021 11:25:57 GMT-0500 (Eastern Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'q',
    'ejs',
    'scsrc/util/utils',
    'scsrc/MoveTemplates/ejsCache',
    'tree-sitter',
    '@movei/tree-sitter-move'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    Q,
    ejs,
    utils,
    ejsCache,
    Parser,
    MoveGrammer) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of MoveCodeGenerator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin MoveCodeGenerator.
     * @constructor
     */
    function MoveCodeGenerator() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
        this.parser = new Parser();
        this.parser.setLanguage(MoveGrammer);
        //this.query = new Parser.Query(MoveGrammer, `struct_definition`)
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    MoveCodeGenerator.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    MoveCodeGenerator.prototype = Object.create(PluginBase.prototype);
    MoveCodeGenerator.prototype.constructor = MoveCodeGenerator;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    MoveCodeGenerator.prototype.main = function (callback) {

        var self = this,
            nodes,
            artifact;

        self.loadNodeMap(self.activeNode)
            .then(function (nodes_) {
                nodes = nodes_;
                return MoveCodeGenerator.getGeneratedFiles(self, nodes, self.activeNode);
            })
            .then(function (result) {
                if (result.violations.length > 0) {
                    result.violations.forEach(function (violation) {
                        self.createMessage(violation.node, violation.message, 'error');
                    });
                    throw new Error('Model has ' + result.violations.length + ' violation(s). ' +
                        'See messages for details.');
                }

                artifact = self.blobClient.createArtifact('MoveCodeGenerator');
                return artifact.addFiles(result.files);
            })
            .then(function (fileHashes) {
                fileHashes.forEach(function (fileHash) {
                    self.result.addArtifact(fileHash);
                });

                return artifact.save();
            })
            .then(function (artifactHash) {
                //self.result.addArtifact(artifactHash);
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                self.logger.error(err.stack);
                // Result success is false at invocation.
                callback(err, self.result);
            });
    };

    MoveCodeGenerator.getGeneratedFiles = function (self, nodes, activeNode, callback) {
        var contractPaths = MoveCodeGenerator.prototype.getContractPaths.call(self, nodes),
            violations = MoveCodeGenerator.prototype.getViolations.call(self, contractPaths, nodes),
            fileNames = [],
            fileName,
            promises = [],
            type;

        for (type of contractPaths) {
            fileName = self.core.getAttribute(nodes[type], 'name') + '.Move';
            fileNames.push(fileName);
            promises.push(MoveCodeGenerator.prototype.getContractFile.call(self, nodes[type], violations));
        }

        return Q.all(promises)
            .then(function (result) {
                var i,
                    files = {};

                for (i = 0; i < fileNames.length; i += 1) {
                    files[fileNames[i]] = result[i];
                }

                return {
                    files: files,
                    violations: violations
                };
            })
            .nodeify(callback);
    };

    MoveCodeGenerator.prototype.getContractPaths = function (nodes) {
        var self = this,
            path,
            node,
            //Using an array for the multiple contracts extention
            contracts = [];

        for (path in nodes) {
            node = nodes[path];
            if (self.isMetaTypeOf(node, self.META.Contract)) {
                contracts.push(path);
            }
        }
        return contracts;
    };

    MoveCodeGenerator.prototype.getContractFile = function (contractNode, violations, callback) {
        var self = this,
            fileContent,
            i;

        return utils.getModelOfContract(self.core, contractNode)
            .then(function (contractModel) {
                fileContent = ejs.render(ejsCache.contractType.complete, contractModel);
                MoveCodeGenerator.prototype.parseResult.call(self, contractNode, fileContent, violations);
                return fileContent;
            })
            .nodeify(callback);
    };

    MoveCodeGenerator.prototype.parseResult = function (contractNode, fileContent, violations) {
        var self = this,
            fileContent,
            i, 
            tree = self.parser.parse(fileContent);

        var cursor = tree.walk(),
            moreSiblings = true,
            moreChildren = true, 
            depth = 0;
        cursor.gotoFirstChild();

        // DFS - Visit all children, and backtrack based on depth
        while(moreSiblings || depth > 0) {
            
            while(moreChildren) {
                if(cursor.nodeType == 'ERROR'){
                    violations.push({
                        node: contractNode,
                        message: "Unexpected : " + fileContent.slice(cursor.startIndex, cursor.endIndex)
                    })
                }
                moreChildren = cursor.gotoFirstChild();
                // Only increment if I went deeper
                if(moreChildren) {
                    depth += 1
                }
            }

            // move to available sibling
            moreSiblings = cursor.gotoNextSibling();
            if (moreSiblings) {
                moreChildren = true;
            } else { 
                // no more siblings backtrack
                cursor.gotoParent();
                depth -= 1;
            }
        }
    }

    MoveCodeGenerator.prototype.getViolations = function (contracts, nodes) {
        var contractNames = {},
            name, type, node,
            child, childPath, childName,
            self = this,
            noInitialState, noCreateTransition,
            nameAndViolations = {
                violations: [],
                totalStateNames: {},
                transitionNames: {}
            };

        for (type of contracts) {
            nameAndViolations.totalStateNames = {};
            nameAndViolations.transitionNames = {};
            noCreateTransition = true;
            noInitialState = true;
            node = nodes[type];
            name = self.core.getAttribute(node, 'name');
            if (contractNames.hasOwnProperty(name)) {
                nameAndViolations.violations.push({
                    node: node,
                    message: 'Name [' + name + '] of contract [' + type + '] is not unique. Please rename. ' +
                        'Contracts must have unique names. '
                });
            }
            contractNames[name] = self.core.getPath(node);
            for (childPath of self.core.getChildrenPaths(node)) {
                child = nodes[childPath];
                childName = self.core.getAttribute(child, 'name');
                if ((self.isMetaTypeOf(child, self.META.InitialState))) {
                    noInitialState = false;
                }
                if ((self.isMetaTypeOf(child, self.META.CreateTransition))) {
                    noCreateTransition = false;
                }
                nameAndViolations = MoveCodeGenerator.prototype.hasChildViolations.call(self, child, childName, nameAndViolations);
            }
            if (noInitialState) {
                nameAndViolations.violations.push({
                    node: node,
                    message: 'Contract type [' + name + '] does not have an initial state. ' +
                        'Please define an initial state.'
                });
            }
            if (noCreateTransition) {
                nameAndViolations.violations.push({
                    node: node,
                    message: 'Contract type [' + name + '] does not have a create transition. ' +
                        'Please define a create transition.'
                });
            }
        }
        return nameAndViolations.violations;
    };

    MoveCodeGenerator.prototype.hasChildViolations = function (child, childName, nameAndViolations) {
        var self = this;

        if ((self.isMetaTypeOf(child, self.META.State)) || (self.isMetaTypeOf(child, self.META.InitialState))) {
            if (nameAndViolations.totalStateNames.hasOwnProperty(childName)) {
                nameAndViolations.violations.push({
                    node: child,
                    message: 'Name [' + childName + '] of state [' + child + '] is not unique. ' +
                        'Please rename. States that belong to the same contract must have unique names.'
                });
            }
            nameAndViolations.totalStateNames[childName] = self.core.getPath(child);
        }
        if (self.isMetaTypeOf(child, self.META.Transition) || self.isMetaTypeOf(child, self.META.CreateTransition)) {

            if (this.core.getPointerPath(child, 'dst') === null) {
                nameAndViolations.violations.push({
                    node: child,
                    message: 'Transition [' + childName + '] with no destination encountered. ' +
                        'Please connect or remove it.'
                });
            }
            if (this.core.getPointerPath(child, 'src') === null) {
                nameAndViolations.violations.push({
                    node: child,
                    message: 'Transition [' + childName + '] with no source encountered. Please connect or remove it.'
                });
            }
            if (!self.core.getAttribute(child, 'tags').match(/^(Acquired|\s|)+$/)) {
                nameAndViolations.violations.push({
                    node: child,
                    message: 'Transition [' + childName + '] has invalid tags. Tags can only be any combination of "Acquired".'
                });
            }
        }
        if (self.isMetaTypeOf(child, self.META.Transition) || self.isMetaTypeOf(child, self.META.CreateTransition)) {

            if (nameAndViolations.transitionNames.hasOwnProperty(childName)) {
                nameAndViolations.violations.push({
                    node: child,
                    message: 'Name [' + childName + '] of transition is not unique. ' +
                        'Please rename. Transitions of the same contract ' +
                        'type must have distinct names.'
                });
            }
            nameAndViolations.transitionNames[childName] = self.core.getPath(child);
        }
        return nameAndViolations;
    };


    return MoveCodeGenerator;
});
